#2025.08.26
#D5
#Greedy 
#왜 다이아 문제를 푸냐? 생각보다 쉬워보였음..

N = int(input())
A = list(map(int, input().split())) + [0,0] #사야하는 라면 개수 #+[0,0]을 해줘야함
#i = n-1일 때, A[i+1] = A[n], A[i+2] = A[n+1]을 참조하게 되어서
#[0,0]을 해줘야 A[n], A[n+1] 은 자동으로 0이 돼서
result = 0

for i in range(N):
    if A[i+1] > A[i+2]:
        #(i, i+1)에서 2개 묶음부터 먼저 처리
        k = min(A[i], A[i+1]-A[i+2])
        A[i] -= k
        A[i+1] -= k
        result += 5 * k
        #2개 묶음 처리 후 3개 묶음 처리
        k = min(A[i], A[i+1], A[i+2])
        A[i] -= k
        A[i+1] -= k
        A[i+2] -= k
        result += 7 * k

    else: #3개 묶음 먼저 처리
        k = min(A[i], A[i+1], A[i+2])
        A[i] -= k
        A[i+1] -= k
        A[i+2] -= k
        result += 7 * k
        #3개 묶음 처리하고 2개 묶음 처리
        k = min(A[i], A[i+1])
        A[i] -= k
        A[i+1] -= k
        result += 5 * k
    #낱개 처리
    result += A[i] * 3
    A[i] = 0

print(result)
"""
단순히 3개 묶음을 최대한 많이 사고 2개 사고 마지막 낱개를 하면 최적의 해가 안나옴
[1,2,1,1] 같은 경우 ㅇㅇ
만약 현재 공장의 다음 공장(A[i+1])이 다다음 공장(A[i+2])보다 더 많은 라면을 갖고 있다면, (i, i+1) 두 공장을 먼저 묶어서 구매합니다
반대로 A[i+1] ≤ A[i+2]라면, 세 공장을 묶는 게 더 유리하므로 (i, i+1, i+2) 세 공장부터 처리합니다.
여전히 현재 공장(A[i])에 라면이 남아 있다면 그것들은 모두 낱개(개당 3원)로 구매합니다. 그리고 A[i]를 0으로 만들어서 처리가 끝났음을 표시합니다.
"""